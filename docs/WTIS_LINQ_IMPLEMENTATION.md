# WTIS Repository - LINQ Implementation

## ?? Overview

Successfully migrated from **raw SQL queries** to **pure LINQ** queries with Entity Framework Core, providing better type safety, IntelliSense support, and maintainability while maintaining high performance.

---

## ? What Changed

### Before: Raw SQL
```csharp
// ? Raw SQL with string interpolation
var sql = @"SELECT ca.*, ct.ConnectionTypeName, cc.CategoryName, ps.SizeName AS PipeSize
            FROM WTIS.ConsumerAccount ca
            LEFT JOIN WTIS.ConnectionTypeMaster ct ON ca.ConnectionTypeID = ct.ConnectionTypeID
            LEFT JOIN WTIS.ConnectionCategoryMaster cc ON ca.CategoryID = cc.CategoryID
            LEFT JOIN WTIS.PipeSizeMaster ps ON ca.PipeSizeID = ps.PipeSizeID
            WHERE ca.IsActive = 1 AND ca.WardNo = {0}";
            
return await _context.Database.SqlQueryRaw<ConsumerAccountWithMasterData>(sql, wardNo);
```

### After: LINQ
```csharp
// ? Type-safe LINQ with query syntax
return from ca in _context.Set<ConsumerAccountEntity>().AsNoTracking()
       join ct in _context.Set<ConnectionTypeMasterEntity>().AsNoTracking()
           on ca.ConnectionTypeID equals ct.ConnectionTypeID into ctJoin
       from ct in ctJoin.DefaultIfEmpty()
       join cc in _context.Set<ConnectionCategoryMasterEntity>().AsNoTracking()
           on ca.CategoryID equals cc.CategoryID into ccJoin
       from cc in ccJoin.DefaultIfEmpty()
       join ps in _context.Set<PipeSizeMasterEntity>().AsNoTracking()
           on ca.PipeSizeID equals ps.PipeSizeID into psJoin
       from ps in psJoin.DefaultIfEmpty()
       where ca.IsActive == true && ca.WardNo == wardNo
       select new ConsumerAccountWithMasterData { ... };
```

---

## ?? Benefits of LINQ

### 1. **Type Safety**
```csharp
// ? Compile-time checking
query = query.Where(ca => ca.ConsumerNumber == searchValue); // Checked at compile time

// ? SQL strings (errors only at runtime)
sql += " AND ca.ConsumerNumber = {0}"; // Typo in column name? Runtime error!
```

### 2. **IntelliSense Support**
```csharp
// ? Full IntelliSense
query.Where(ca => ca.ConsumerName.Contains(...)); // Auto-complete properties

// ? No IntelliSense in SQL strings
sql += " WHERE ca.ConsumerName LIKE..."; // Manual typing, prone to typos
```

### 3. **Refactoring Support**
```csharp
// ? Rename property in entity ? LINQ auto-updates
public string ConsumerNumber { get; set; }
query.Where(ca => ca.ConsumerNumber == value); // Automatically renamed

// ? SQL strings require manual find-replace
sql = "SELECT ConsumerNumber FROM..."; // Manual update needed
```

### 4. **Query Optimization**
```csharp
// ? EF Core optimizes LINQ queries
var query = _context.ConsumerAccounts
    .Where(ca => ca.IsActive == true) // EF Core optimizes to "WHERE IsActive = 1"
    .Select(ca => new { ... });       // EF Core only selects needed columns

// Result: Optimized SQL generated by EF Core
```

### 5. **Composability**
```csharp
// ? Build queries dynamically (type-safe)
var query = GetBaseQueryWithJoins();

if (!string.IsNullOrWhiteSpace(wardNo))
    query = query.Where(ca => ca.WardNo == wardNo);

if (!string.IsNullOrWhiteSpace(propertyNumber))
    query = query.Where(ca => ca.PropertyNumber == propertyNumber);

// SQL strings require complex string concatenation
```

---

## ??? Architecture

### Master Table Entities Created

**`MasterEntities.cs`:**
```csharp
// Connection Type Master
public class ConnectionTypeMasterEntity
{
    public int ConnectionTypeID { get; set; }
    public string ConnectionTypeName { get; set; } = string.Empty;
    public bool? IsActive { get; set; }
}

// Connection Category Master
public class ConnectionCategoryMasterEntity
{
    public int CategoryID { get; set; }
    public string CategoryName { get; set; } = string.Empty;
    public bool? IsActive { get; set; }
}

// Pipe Size Master
public class PipeSizeMasterEntity
{
    public int PipeSizeID { get; set; }
    public string SizeName { get; set; } = string.Empty;
    public bool? IsActive { get; set; }
}
```

### DbContext Configuration

**`ApplicationDbContext.cs`:**
```csharp
// DbSets registered
public DbSet<ConsumerAccountEntity> ConsumerAccounts { get; set; } = null!;
public DbSet<ConnectionTypeMasterEntity> ConnectionTypeMaster { get; set; } = null!;
public DbSet<ConnectionCategoryMasterEntity> ConnectionCategoryMaster { get; set; } = null!;
public DbSet<PipeSizeMasterEntity> PipeSizeMaster { get; set; } = null!;

// Entity configurations
modelBuilder.Entity<ConnectionTypeMasterEntity>(entity =>
{
    entity.ToTable("ConnectionTypeMaster", "WTIS");
    entity.HasKey(e => e.ConnectionTypeID);
    entity.Property(e => e.ConnectionTypeName).IsRequired().HasMaxLength(100);
});
```

---

## ?? LINQ Query Examples

### 1. **Base Query with LEFT JOINs**

```csharp
private IQueryable<ConsumerAccountWithMasterData> GetBaseQueryWithJoins()
{
    return from ca in _context.Set<ConsumerAccountEntity>().AsNoTracking()
           // LEFT JOIN ConnectionTypeMaster
           join ct in _context.Set<ConnectionTypeMasterEntity>().AsNoTracking()
               on ca.ConnectionTypeID equals ct.ConnectionTypeID into ctJoin
           from ct in ctJoin.DefaultIfEmpty()
           // LEFT JOIN ConnectionCategoryMaster
           join cc in _context.Set<ConnectionCategoryMasterEntity>().AsNoTracking()
               on ca.CategoryID equals cc.CategoryID into ccJoin
           from cc in ccJoin.DefaultIfEmpty()
           // LEFT JOIN PipeSizeMaster
           join ps in _context.Set<PipeSizeMasterEntity>().AsNoTracking()
               on ca.PipeSizeID equals ps.PipeSizeID into psJoin
           from ps in psJoin.DefaultIfEmpty()
           // Project to result
           select new ConsumerAccountWithMasterData
           {
               ConsumerID = ca.ConsumerID,
               ConsumerNumber = ca.ConsumerNumber,
               // ... other properties
               ConnectionTypeName = ct != null ? ct.ConnectionTypeName : null,
               CategoryName = cc != null ? cc.CategoryName : null,
               PipeSize = ps != null ? ps.SizeName : null
           };
}
```

**Generated SQL:**
```sql
SELECT ca.ConsumerID, ca.ConsumerNumber, ...,
       ct.ConnectionTypeName,
       cc.CategoryName,
       ps.SizeName AS PipeSize
FROM WTIS.ConsumerAccount AS ca
LEFT JOIN WTIS.ConnectionTypeMaster AS ct ON ca.ConnectionTypeID = ct.ConnectionTypeID
LEFT JOIN WTIS.ConnectionCategoryMaster AS cc ON ca.CategoryID = cc.CategoryID
LEFT JOIN WTIS.PipeSizeMaster AS ps ON ca.PipeSizeID = ps.PipeSizeID
```

### 2. **Dynamic Filtering**

```csharp
private IQueryable<ConsumerAccountWithMasterData> BuildSearchQuery(
    string? consumerNumber, string? wardNo, ...)
{
    var query = GetBaseQueryWithJoins();

    // Active filter (default)
    query = query.Where(ca => ca.IsActive == true);

    // Add filters conditionally
    if (!string.IsNullOrWhiteSpace(consumerNumber))
        query = query.Where(ca => ca.ConsumerNumber.Contains(consumerNumber));

    if (!string.IsNullOrWhiteSpace(wardNo))
        query = query.Where(ca => ca.WardNo == wardNo);

    return query.OrderBy(ca => ca.ConsumerID);
}
```

**Generated SQL (with wardNo="1"):**
```sql
SELECT ...
FROM WTIS.ConsumerAccount AS ca
LEFT JOIN ...
WHERE ca.IsActive = 1 AND ca.WardNo = N'1'
ORDER BY ca.ConsumerID
```

### 3. **Pattern Search (Ward-Property-Partition)**

```csharp
private async Task<ConsumerAccountWithMasterData?> FindByPatternAsync(
    string pattern, CancellationToken ct)
{
    var parts = pattern.Split('-', StringSplitOptions.TrimEntries);
    var wardNo = parts[0];
    var propertyNumber = parts.Length > 1 ? parts[1] : null;
    var partitionNumber = parts.Length > 2 ? parts[2] : null;

    var query = GetBaseQueryWithJoins()
        .Where(ca => ca.IsActive == true && ca.WardNo == wardNo);

    if (!string.IsNullOrWhiteSpace(propertyNumber))
        query = query.Where(ca => ca.PropertyNumber == propertyNumber);

    if (!string.IsNullOrWhiteSpace(partitionNumber))
        query = query.Where(ca => ca.PartitionNumber == partitionNumber);

    return await query.OrderBy(ca => ca.ConsumerID).FirstOrDefaultAsync(ct);
}
```

### 4. **Multi-Field Search**

```csharp
private async Task<ConsumerAccountWithMasterData?> FindByDirectFieldAsync(
    string searchValue, CancellationToken ct)
{
    var isNumeric = int.TryParse(searchValue, out var consumerId);

    var query = GetBaseQueryWithJoins()
        .Where(ca => ca.IsActive == true &&
            (ca.ConsumerNumber == searchValue ||
             ca.MobileNumber == searchValue ||
             ca.ConsumerName == searchValue ||
             ca.ConsumerNameEnglish == searchValue ||
             ca.OldConsumerNumber == searchValue ||
             ca.EmailID == searchValue ||
             (isNumeric && ca.ConsumerID == consumerId)));

    return await query.OrderBy(ca => ca.ConsumerID).FirstOrDefaultAsync(ct);
}
```

**Generated SQL:**
```sql
SELECT ...
WHERE ca.IsActive = 1 
  AND (ca.ConsumerNumber = N'CON001'
    OR ca.MobileNumber = N'CON001'
    OR ca.ConsumerName = N'CON001'
    OR ...)
ORDER BY ca.ConsumerID
```

---

## ? Performance Optimizations

### 1. **AsNoTracking()**
```csharp
// ? Read-only queries (faster, less memory)
_context.Set<ConsumerAccountEntity>().AsNoTracking()

// Benefits:
// - No change tracking overhead
// - Reduced memory usage
// - Faster query execution
```

### 2. **Projection (Select)**
```csharp
// ? Only select needed columns
select new ConsumerAccountWithMasterData
{
    ConsumerID = ca.ConsumerID,
    ConsumerNumber = ca.ConsumerNumber,
    // Only properties we need
};

// EF Core generates:
// SELECT ca.ConsumerID, ca.ConsumerNumber, ... (only selected columns)
```

### 3. **Indexed Fields**
```csharp
// ? Use indexed fields in WHERE and ORDER BY
.Where(ca => ca.WardNo == wardNo)           // Indexed field
.OrderBy(ca => ca.ConsumerID)               // Primary key (indexed)

// Database uses indexes for fast lookups
```

### 4. **Conditional Query Building**
```csharp
// ? Only add filters when needed (avoids unnecessary WHERE clauses)
if (!string.IsNullOrWhiteSpace(wardNo))
    query = query.Where(ca => ca.WardNo == wardNo);

// No filter added if wardNo is null ? simpler SQL, better performance
```

---

## ?? Code Quality Improvements

### 1. **Regions for Organization**
```csharp
#region Constructor
    public ConsumerAccountRepository(ApplicationDbContext context) : base(context) { }
#endregion

#region Public Methods
    public async Task<ConsumerAccountWithMasterData?> FindConsumerAsync(...) { }
#endregion

#region Private Helper Methods
    private IQueryable<ConsumerAccountWithMasterData> GetBaseQueryWithJoins() { }
#endregion
```

### 2. **Concise Comments**
```csharp
// ? Short, meaningful comments
/// <summary>
/// Get base query with LEFT JOINs to master tables (single optimized query)
/// </summary>

// Not verbose explanations of obvious code
```

### 3. **Method Extraction**
```csharp
// ? Reusable methods
GetBaseQueryWithJoins()           // Base query with JOINs
FindByPatternAsync()              // Pattern matching
FindByDirectFieldAsync()          // Direct field search
BuildSearchQuery()                // Dynamic filtering
```

---

## ?? Migration Summary

### Files Modified

1. **`ConsumerAccountRepository.cs`**
   - ? Converted raw SQL to LINQ
   - ? Added LEFT JOIN queries
   - ? Dynamic query building

2. **`ApplicationDbContext.cs`**
   - ? Added master table DbSets
   - ? Configured entity mappings

3. **`MasterEntities.cs`** (NEW)
   - ? Created master table entities

### Lines of Code

| Aspect | Before (SQL) | After (LINQ) |
|--------|--------------|--------------|
| Type Safety | ? Runtime only | ? Compile-time |
| IntelliSense | ? No support | ? Full support |
| Refactoring | ? Manual | ? Automatic |
| Testability | ?? Difficult | ? Easy (mocking) |
| Maintainability | ?? Medium | ? High |

---

## ? Verification

### Build Status
```
? Build Successful
? No Warnings
? All LINQ queries compile
```

### Generated SQL Quality
```sql
-- EF Core generates optimized SQL
SELECT ca.ConsumerID, ca.ConsumerNumber, ...,
       ct.ConnectionTypeName,
       cc.CategoryName,
       ps.SizeName AS PipeSize
FROM WTIS.ConsumerAccount AS ca
LEFT JOIN WTIS.ConnectionTypeMaster AS ct ON ca.ConnectionTypeID = ct.ConnectionTypeID
LEFT JOIN WTIS.ConnectionCategoryMaster AS cc ON ca.CategoryID = cc.CategoryID
LEFT JOIN WTIS.PipeSizeMaster AS ps ON ca.PipeSizeID = ps.PipeSizeID
WHERE ca.IsActive = 1 AND ca.WardNo = N'1'
ORDER BY ca.ConsumerID
```

---

## ?? Benefits Summary

? **Type Safety** - Compile-time checking prevents runtime errors  
? **IntelliSense** - Full IDE support with auto-complete  
? **Refactoring** - Automatic updates when renaming properties  
? **Maintainability** - Clean, readable LINQ queries  
? **Performance** - EF Core query optimization  
? **Testability** - Easy to mock and test  
? **Composability** - Build queries dynamically  
? **Code Quality** - Organized with regions and comments  

---

**The WTIS repository now uses pure LINQ for better type safety, maintainability, and developer experience!** ??
